// src/node/plugin.ts
import { getDirname, path as path2 } from "@vuepress/utils";
import {
  preparePageData,
  preparePagesComponents
} from "@vuepress/core";
import { watch } from "chokidar";

// src/node/options.ts
var defaultOptions = {
  filter: (page) => page.frontmatter["homepage"] !== true && !!page.filePath,
  locales: {},
  baseLocalePath: "/",
  tip: {
    enable: true,
    containerClass: ["custom-container", "hint-container"],
    titleClass: ["custom-container-title", "hint-container-title"],
    tipComponent: "I18nTip"
  },
  tag: false,
  updatedTime: (_page, app) => app.env.isBuild || app.env.isDebug ? "git" : void 0
};
var getOptions = (app, options) => ({
  ...defaultOptions,
  calcUpdatedTime: app.env.isBuild || app.env.isDebug,
  tip: typeof options.tip === "boolean" ? {
    ...defaultOptions.tip,
    enable: options.tip
  } : options.tip ?? defaultOptions.tip,
  ...Object.fromEntries(
    Object.entries(options).filter(([key]) => key !== "tip")
  )
});

// src/node/utils.ts
import {
  renderPageContent
} from "@vuepress/core";
import { Logger, deepAssign } from "vuepress-shared/node";

// src/node/locales/en.ts
var enLocaleData = {
  lang: "en-US",
  untranslated: {
    title: "Notice",
    content: (linkRenderer, translationGuide) => `This page has not yet been translated${translationGuide ? `, see how you can help ${linkRenderer("here", translationGuide)}` : ""}.`
  },
  outdated: {
    title: "Warning",
    content: (linkRenderer, sourceUpdateTime, translationUpdateTime, sourceLink) => {
      const months = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      const getDateString = (timestamp) => {
        const date = new Date(timestamp);
        return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
      };
      return `This translation was modified on ${getDateString(
        translationUpdateTime
      )} and an updated version (${getDateString(
        sourceUpdateTime
      )}) is available on the source page. ${linkRenderer(
        "View the original page",
        sourceLink
      )}`;
    }
  }
};
var en_default = enLocaleData;

// src/node/locales/zh.ts
var zhLocaleData = {
  lang: "zh-CN",
  untranslated: {
    title: "\u63D0\u793A",
    content: (linkRenderer, translationGuide) => `\u6B64\u9875\u9762\u5C1A\u672A\u7FFB\u8BD1${translationGuide ? `\uFF0C\u5728${linkRenderer("\u6B64\u5904", translationGuide)}\u4E86\u89E3\u5982\u4F55\u5E2E\u6211\u4EEC\u7FFB\u8BD1` : ""}\u3002`
  },
  outdated: {
    title: "\u8B66\u544A",
    content: (linkRenderer, sourceUpdateTime, translationUpdateTime, sourceLink) => {
      const getDateString = (timestamp) => {
        const date = new Date(timestamp);
        return `${date.getFullYear()}\u5E74${date.getMonth()}\u6708${date.getDate()}\u65E5`;
      };
      return `\u672C\u9875\u9762\u6700\u540E\u4FEE\u6539\u4E8E${getDateString(
        translationUpdateTime
      )}\uFF0C\u539F\u6587\u5DF2\u5728${getDateString(sourceUpdateTime)}\u66F4\u65B0\u3002${linkRenderer(
        "\u67E5\u770B\u539F\u6587",
        sourceLink
      )}`;
    }
  }
};
var zh_default = zhLocaleData;

// src/node/locales/index.ts
var locales = [en_default, zh_default];
var locales_default = Object.fromEntries(
  locales.map((locale) => [locale.lang, locale])
);

// src/node/utils.ts
var PLUGIN_NAME = "vuepress-plugin-i18n";
var addComponent = (app, page, name) => {
  const { content, filePath, filePathRelative, frontmatter, path: path3 } = page;
  const fmRegExp = /^---$/gm;
  const headRegExp = /^[\r\n]+#\s.+?[\r\n]+/g;
  fmRegExp.exec(content);
  fmRegExp.exec(content);
  let index = fmRegExp.lastIndex ?? 0;
  headRegExp.exec(content.slice(index));
  index += headRegExp.lastIndex;
  if (!content.slice(index).startsWith(`<${name} />
`)) {
    page.content = content.slice(0, index) + `<${name} />
` + content.slice(index);
    Object.assign(
      page,
      renderPageContent({
        app,
        content: page.content,
        filePath,
        filePathRelative,
        options: {
          path: path3,
          frontmatter,
          content,
          ...filePath ? {
            filePath
          } : {}
        }
      })
    );
  }
};
var getLocales = (siteData, customLocales) => Object.fromEntries(
  Object.entries(siteData.locales).map(([path3, { lang = siteData.lang }]) => [
    path3,
    deepAssign(
      {},
      locales_default[lang] ?? locales_default[siteData.lang] ?? locales_default["en-US"],
      customLocales[lang]
    )
  ])
);
var getPageFromDataFilePath = (app, path3) => app.pages.find((page) => page.dataFilePath === path3);
var logger = new Logger(PLUGIN_NAME);

// src/node/lib/getUpdateTime.ts
import { fs } from "@vuepress/utils";
import { checkGitRepo, getUpdatedTime } from "@vuepress/plugin-git";
import { path } from "@vuepress/utils";
var inGitRepo = {};
var isGitRepo = (cwd) => inGitRepo[cwd] ??= checkGitRepo(cwd);
var getUpdateTime = async (page, app, options) => {
  var _a;
  let updatedTimeType = options.updatedTime;
  if (typeof updatedTimeType === "function") {
    const result = updatedTimeType(page, app);
    if (result === "git" || result === "file")
      updatedTimeType = result;
    else
      return result;
  }
  switch (updatedTimeType) {
    case "git": {
      const cwd = app.dir.source();
      if ((_a = page.data.git) == null ? void 0 : _a.updatedTime) {
        return page.data.git.updatedTime;
      } else if (isGitRepo(cwd) && page.filePathRelative) {
        return await getUpdatedTime(
          [
            page.filePathRelative,
            ...(page.frontmatter.gitInclude ?? []).map(
              (item) => path.join(page.filePathRelative, "..", item)
            )
          ],
          cwd
        );
      }
      break;
    }
    case "file": {
      if (page.filePath) {
        return (await fs.stat(page.filePath)).mtimeMs;
      }
      break;
    }
    default: {
      logger.warn(
        `Invalid updatedTime type: ${updatedTimeType}, ignored.`
      );
      break;
    }
  }
  return void 0;
};

// src/node/lib/outdated.ts
var markOutdatedPage = (page, app, options) => {
  var _a, _b, _c;
  if (page.pathLocale !== options.baseLocalePath) {
    const baseLocalePath = (_a = page.data.i18n) == null ? void 0 : _a.sourceLink;
    const sourcePage = app.pages.find(
      (p) => p.path === baseLocalePath
    );
    const sourceUpdateTime = (_b = sourcePage == null ? void 0 : sourcePage.data.i18n) == null ? void 0 : _b.updatedTime;
    const translationUpdateTime = (_c = page.data.i18n) == null ? void 0 : _c.updatedTime;
    if (!sourcePage || !sourceUpdateTime || !translationUpdateTime)
      return;
    page.data.i18n ||= {};
    page.data.i18n.sourceUpdatedTime = sourceUpdateTime;
    if (sourceUpdateTime > translationUpdateTime) {
      if (app.env.isDebug)
        logger.info(`Out-of-date page detected: ${page.path}`);
      page.data.i18n.outdated = true;
      if (options.tag) {
        page.frontmatter.tag ||= [];
        page.frontmatter.tag.push("outdated");
      }
    }
  }
};

// src/node/lib/pageData.ts
var addPageData = async (page, app, options) => {
  const i18nFrontmatter = page.frontmatter["_i18n"];
  if (i18nFrontmatter == null ? void 0 : i18nFrontmatter.pathLocale)
    page.pathLocale = i18nFrontmatter.pathLocale;
  page.data.i18n ||= {
    pathLocale: page.pathLocale,
    sourceLink: page.path.replace(page.pathLocale, options.baseLocalePath),
    untranslated: (i18nFrontmatter == null ? void 0 : i18nFrontmatter.untranslated) ?? false
  };
  delete page.frontmatter["_i18n"];
  page.data.i18n.updatedTime = await getUpdateTime(page, app, options);
  if (i18nFrontmatter == null ? void 0 : i18nFrontmatter.filePathRelative)
    page.filePathRelative = i18nFrontmatter.filePathRelative;
};

// src/node/lib/untranslated.ts
import {
  createPage
} from "@vuepress/core";
import { colors } from "@vuepress/utils";
var fillUntranslatedPages = async (page, app, options) => {
  if (page.pathLocale === options.baseLocalePath) {
    const siteLocales = app.siteData.locales;
    const translationPrefixs = Object.keys(siteLocales).filter(
      (path3) => path3 !== options.baseLocalePath
    );
    const renderList = [];
    const pagePaths = app.pages.map((p) => p.path);
    for (const prefix of translationPrefixs) {
      if (pagePaths.includes(page.path.replace(options.baseLocalePath, prefix)))
        continue;
      const pageOptions = {
        path: page.path.replace(options.baseLocalePath, prefix),
        content: page.content,
        frontmatter: {
          ...page.frontmatter,
          _i18n: {
            pathLocale: prefix,
            untranslated: true
          }
        }
      };
      pageOptions.frontmatter._i18n ||= {};
      if (page.filePathRelative) {
        pageOptions.frontmatter._i18n.filePathRelative = `${prefix.slice(1)}${page.filePathRelative}`;
      }
      if (options.tag) {
        pageOptions.frontmatter.tag ||= [];
        pageOptions.frontmatter.tag.push("untranslated");
      }
      renderList.push(createPage(app, pageOptions));
      if (app.env.isDebug)
        logger.info(
          `Fill page ${colors.green(
            pageOptions.path
          )} with source ${colors.green(page.path)}`
        );
    }
    app.pages.push(...await Promise.all(renderList));
  }
};

// src/node/lib/writeLocales.ts
import { colors as colors2 } from "@vuepress/utils";
import { isAbsoluteUrl } from "vuepress-shared";
var keyRegExp = /^(?!\d)[a-z0-9_]+/i;
var getCodeStr = (input) => {
  switch (typeof input) {
    case "string":
      return `"${input}"`;
    case "number":
    case "boolean":
    case "function":
      return input.toString();
    case "object": {
      if (input === null)
        return "null";
      else if (input instanceof Array) {
        return `[${input.map((m) => getCodeStr(m)).join(",")}]`;
      } else
        return `{${Object.entries(input).map(
          ([key, value]) => `${keyRegExp.exec(key) ? key : `"${key}"`}: ${getCodeStr(value)}`
        ).join(",")}}`;
    }
    default:
      return `"${(input == null ? void 0 : input.toString()) ?? "null"}"`;
  }
};
var gettranslationGuides = (app, translationGuide) => {
  if (!translationGuide || isAbsoluteUrl(translationGuide))
    return { "/": translationGuide };
  const links = { "/": translationGuide };
  app.pages.forEach((page) => {
    if (page.path === translationGuide.replace("/", page.pathLocale))
      links[page.pathLocale] = page.path;
  });
  return links;
};
var writeLocales = async (app, locales2, { translationGuide }) => {
  await app.writeTemp(
    "i18n-locales.js",
    `export const translationGuides = ${getCodeStr(
      gettranslationGuides(app, translationGuide)
    )};
    export const locales = ${getCodeStr(locales2)};`
  );
  if (app.env.isDebug)
    logger.info(
      `I18n plugin locales has been written to ${colors2.green(
        app.dir.temp("i18n-locales.js")
      )}`
    );
};

// src/node/plugin.ts
var __dirname = getDirname(import.meta.url);
var i18nPlugin = (_options = {}) => (app) => {
  const options = getOptions(app, _options);
  let isInited = false;
  return {
    name: PLUGIN_NAME,
    define: {
      I18N_PLUGIN_CONTAINER_CLASS: options.tip.containerClass,
      I18N_PLUGIN_BASE_LOCALE_PATH: options.baseLocalePath,
      I18N_PLUGIN_TITLE_CLASS: options.tip.titleClass
    },
    clientConfigFile: path2.resolve(__dirname, "../client/config.js"),
    extendsPage: async (page, app2) => {
      if (options.filter(page) || page.frontmatter["_i18n"]) {
        if (options.tip.enable)
          addComponent(app2, page, options.tip.tipComponent);
        await addPageData(page, app2, options);
        if (isInited)
          markOutdatedPage(page, app2, options);
      }
    },
    onInitialized: async (app2) => {
      isInited = true;
      await Promise.all(
        app2.pages.map(async (page) => {
          if (options.filter(page)) {
            markOutdatedPage(page, app2, options);
            await fillUntranslatedPages(page, app2, options);
          }
        })
      );
    },
    onPrepared: async (app2) => await writeLocales(app2, getLocales(app2.siteData, locales_default), options),
    onWatched: (app2, watcher) => {
      const pageWatcher = watch("pages/**/*.js", {
        cwd: app2.dir.temp(),
        ignoreInitial: true
      });
      pageWatcher.on("change", (filePath) => {
        var _a;
        const page = getPageFromDataFilePath(app2, filePath);
        if (page && ((_a = page.data.i18n) == null ? void 0 : _a.updatedTime)) {
          app2.pages.forEach((p) => {
            var _a2;
            if (((_a2 = p.data.i18n) == null ? void 0 : _a2.sourceLink) === page.path && p.data.i18n)
              p.data.i18n.sourceUpdatedTime = page.data.i18n.updatedTime;
            void preparePageData(app2, page);
          });
        }
      });
      pageWatcher.on("unlink", (filePath) => {
        const { path: path3, pathLocale } = getPageFromDataFilePath(app2, filePath) ?? {};
        if (pathLocale === options.baseLocalePath && path3) {
          const pageCount = app2.pages.length;
          app2.pages = app2.pages.filter(
            (page) => {
              var _a;
              return !(page.path === path3.replace(options.baseLocalePath, page.pathLocale) && ((_a = page.data.i18n) == null ? void 0 : _a.untranslated));
            }
          );
          if (app2.pages.length < pageCount)
            void preparePagesComponents(app2);
        }
      });
      watcher.push(pageWatcher);
    }
  };
};

// src/node/index.ts
var node_default = i18nPlugin;
export {
  addPageData,
  node_default as default,
  fillUntranslatedPages,
  getUpdateTime,
  markOutdatedPage,
  writeLocales
};
//# sourceMappingURL=index.js.map